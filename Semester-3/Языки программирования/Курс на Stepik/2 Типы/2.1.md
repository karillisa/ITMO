# 2.1 Обзор системы типов, численные типы

## _5/15_

Существует численный тип называющийся `unsigned long long int`. Это беззнаковое целое число.

1. Обратитесь к параграфу 5.2.4.2.1 стандарта [ISO/IEC 9899:2017](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf) и узнайте про ограничения на этот тип.
2. Представим, что мы сделали такой компилятор языка С, для которого переменная типа `unsigned long long int` может принимать значение 18446744073709551616. Соответствует ли этот компилятор стандарту C18?

Выберите один вариант из списка

### ___Ответ:___
- [x] Да, такой компилятор соответствует стандарту языка
- [ ] Нет, такой компилятор нарушает стандарт
- [ ] Ни один из ответов не является правильным

---

## _9/15_

Создайте массив правильного типа и определите функцию в соответствии с комментариями.

Можно считать, что все числа в массиве не превышают 4294900000 и неотрицательны.

### ___Ответ:___

```c
// Определите массив в котором будут 8*1024*1024 чисел
// Массив не должен занимать больше 40 МБ памяти

uint32_t data[8*1024*1024] = {0};

// Определите функцию count_gt
// Она должна вернуть количество чисел в data, которые больше LIMIT
// LIMIT это определение препроцессора, оно вам уже доступно
// скрытый от вас код заполнит массив data числами и проверит правильность
// вашей функции
size_t count_gt(uint32_t *array, size_t size) {
    size_t count = 0;
    
    for (size_t i = 0; i < size; i++) {
        if (array[i] > LIMIT) {
            count++;
        }
    }
    
    return count;
}
```

---

## _15/15_

Напишите функцию, которая считает количество нулевых байтов в массиве. Будьте внимательны:

- Массив может быть любого типа; если он содержит, например, числа размером 4 байта, то в каждом числе нулевых байтов может быть несколько.
- Функция должна корректно работать с неизменяемыми массивами любого типа, ведь она не изменяет их содержимое.
- На вход функции подается не количество элементов, а размер массива в байтах `sz`.

### ___Ответ:___

```c
size_t count_zeroes(const void *data, size_t sz) {
    size_t count = 0;
    const uint8_t* byte_data = data; 

    for (size_t i = 0; i < sz; i++) {
        if (byte_data[i] == 0) {
            count++;
        }
    }

    return count;
}
```
